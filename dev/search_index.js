var documenterSearchIndex = {"docs":
[{"location":"#BosonStrings","page":"Getting started","title":"BosonStrings","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Normal ordered strings of bosonic operators in Julia.","category":"page"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"] add https://github.com/nicolasloizeau/BosonStrings.jl","category":"page"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"#Algebra","page":"Getting started","title":"Algebra","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Compute a_1^dagger 1 a_1^1 cdot a_1^dagger 2 a_1^2","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"using BosonStrings\no1 = Operator(1)\no1 += 1, (1, 1, 1)\no2 = Operator(1)\no2 += 1, (1, 2, 2)\no = o1 * o2\nprintln(o)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"julia> o\n(1.0 + 0.0im) (†3)(3)\n(2.0 + 0.0im) (†2)(2)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"we get a_1^dagger 1 a_1^1 cdot a_1^dagger 2 a_1^2 = a_1^dagger 3 a_1^3 + 2a_1^dagger 2 a_1^2","category":"page"},{"location":"#Expectation-values-with-Fock-States","page":"Getting started","title":"Expectation values with Fock States","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Compute langle 2 o 2 rangle:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"julia> inner(2, o, 2)\n4.0 + 0.0im","category":"page"},{"location":"constructing/#Constructing-operators","page":"Constructing operators","title":"Constructing operators","text":"","category":"section"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Start by importing BosonStrings:","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"using BosonStrings","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Operators are constructed by adding Bonsons strings. A boson strings is formated in the following waw : c, (site1, n1,m1), (site2, n2,m2), (site3, n3,m3) ... where c is a coefficient, and triples (site, n, m) denote a term of the form a_site^dagger n a_site^m. A Boson string is a tensor product of such sigle site terms.","category":"page"},{"location":"constructing/#Single-mode","page":"Constructing operators","title":"Single mode","text":"","category":"section"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Compute a_1^dagger 1 a_1^1 cdot a_1^dagger 2 a_1^2","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"o1 = Operator(1)\no1 += 1, (1, 1, 1)\no2 = Operator(1)\no2 += 1, (1, 2, 2)\no = o1 * o2\nprintln(o)","category":"page"},{"location":"constructing/#Multi-mode","page":"Constructing operators","title":"Multi mode","text":"","category":"section"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Compute a_1^dagger 1 a_1^1 a_2^dagger 1 a_2^5 cdot a_1^dagger 2 a_1^2 a_4^dagger 2 a_4^6","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"o1 = Operator(4)\no1 += 1, (1, 1, 1), (2, 1, 5)\no2 = Operator(4)\no2 += 1, (1, 2, 2), (4, 2, 6)\no = o1 * o2\nprintln(o)","category":"page"},{"location":"docstrings/","page":"Documentation","title":"Documentation","text":"CurrentModule = BosonStrings","category":"page"},{"location":"docstrings/#BosonStrings","page":"Documentation","title":"BosonStrings","text":"","category":"section"},{"location":"docstrings/","page":"Documentation","title":"Documentation","text":"Documentation for BosonStrings.","category":"page"},{"location":"docstrings/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"docstrings/","page":"Documentation","title":"Documentation","text":"Modules = [BosonStrings]","category":"page"},{"location":"docstrings/#BosonStrings.Operator","page":"Documentation","title":"BosonStrings.Operator","text":"Represent an normal ordered boson operator Each key is a\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.:*-Tuple{Operator, Operator}","page":"Documentation","title":"Base.:*","text":"Base.:*(o1::Operator, o2::Operator)\n\nMultiplication of two operators. Only supports single boson operator for now.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Tuple{Matrix{T} where T, Tuple{Number, Tuple{Int64, Int64}}}","page":"Documentation","title":"Base.:+","text":"Base.:+(o::Matrix, term::Tuple{Number, Tuple{Int,Int} })\n\nAdd a term to a dense matrix operator. To add a term of the form c*(†n)(m), do o+=c,n,m\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Tuple{Operator, Operator}","page":"Documentation","title":"Base.:+","text":"Base.:+(o1::Operator, o2::Operator)\nBase.:+(o::Operator, a::Number)\nBase.:+(a::Number, o::Operator)\n\nAddition between operators and numbers\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Tuple{Operator, Tuple{Number, Vararg{Tuple{Int64, Int64, Int64}, N} where N}}","page":"Documentation","title":"Base.:+","text":"Base.:+(o::Operator, term::Tuple{Number, Vararg{Tuple{Int,Int,Int}} })\n\nAdd a term to an operator. The term is of the form c, (site1, n1, m1), (site2, n2, m2) ... where triplets (site, n, m) represent a_site^dagger n a_site^m. The following example adds the term a_1^dagger 1 a_1^1    a_2^dagger 2 a_2^3    a_4^dagger 5 a_4^5 to a 4-bosons operator:\n\no = Operator(4)\no += 1, (1, 1, 1), (2, 2, 3), (4, 5, 5)\n\njulia> o\n(1.0 + 0.0im) (†1)(1)·(†2)(3)·(†0)(0)·(†5)(5)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:--Tuple{Operator}","page":"Documentation","title":"Base.:-","text":"Base.:-(o::Operator)\nBase.:-(o1::Operator, o2::Operator)\nBase.:-(o::Operator, a::Number)\nBase.:-(a::Number, o::Operator)\n\nSubtraction between operators and numbers\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:/-Tuple{Operator, Number}","page":"Documentation","title":"Base.:/","text":"Base.:/(o::Operator, a::Number)\n\nDivide an operator by a number\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.show-Tuple{IO, Operator}","page":"Documentation","title":"Base.show","text":"Base.show(io::IO, o::Operator)\n\nPrint an operator in a human-readable format. The operator is printed as a sum of terms, each term is a coefficient followed by a string of boson operators.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.annihilation-Tuple{Int64}","page":"Documentation","title":"BosonStrings.annihilation","text":"annihilation(d::Int)\n\nCreate a d x d annihilation operator, dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.equal-Tuple{Operator, Operator}","page":"Documentation","title":"BosonStrings.equal","text":"equal(o1, o2; tol=1e-10)\n\nCompare two operators. Return true if they are equal within the tolerance tol.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.expect-Tuple{Operator, Int64, Int64}","page":"Documentation","title":"BosonStrings.expect","text":"expect(o::Operator, in_state::n, out_state::m)\n\nReturn <n|o|m> where |m> and |n> are foch states. TODO : many body\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.inner-Tuple{Int64, Matrix{T} where T, Int64}","page":"Documentation","title":"BosonStrings.inner","text":"inner(n::Int, o::Matrix, m::Int)\n\nReturn <n|o|m> where o is a single boson operator represented as a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.inner-Tuple{Int64, Operator, Int64}","page":"Documentation","title":"BosonStrings.inner","text":"inner(n::Int, o::Operator, m::Int)\n\nReturn <n|o|m> where |n> and |m> are foch states. TODO : many body\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.ione-Tuple{Operator}","page":"Documentation","title":"BosonStrings.ione","text":"return the index of the 1 string\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.op_to_dense-Tuple{Operator, Int64}","page":"Documentation","title":"BosonStrings.op_to_dense","text":"op_to_dense(o::Operator, dim::Int)\n\nConvert a boson Operator to a dense matrix of dimention dim.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.rk4-Tuple{Operator, Operator, Real}","page":"Documentation","title":"BosonStrings.rk4","text":"rk4(H::Operator, O::Operator, dt::Real; hbar::Real=1, heisenberg=true, M=2^20, keep::Operator=Operator(N))\n\nSingle step of Runge–Kutta-4 with time independant Hamiltonian. Returns O(t+dt). Set heisenberg=true for evolving an observable in the heisenberg picture. If heisenberg=false then it is assumed that O is a density matrix. M is the number of strings to keep.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#BosonStrings.trim-Tuple{Operator, Int64}","page":"Documentation","title":"BosonStrings.trim","text":"trim(o::Operator, max_strings::Int)\n\nKeep the first max_strings terms with largest coeficients.\n\n\n\n\n\n","category":"method"}]
}
